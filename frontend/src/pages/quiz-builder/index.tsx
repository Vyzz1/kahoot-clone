import { useState, useEffect } from "react";
import { Button, Divider, message, Flex, Typography, Form, Input, Select, List, Tag, Tooltip, Switch } from "antd";
import { useNavigate } from "react-router-dom";
import { v4 as uuidv4 } from "uuid"; // Still used for temporary frontend IDs if needed, but not for backend _id
import { EditOutlined, DeleteOutlined, ClockCircleOutlined } from "@ant-design/icons";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import useAxiosPrivate from "../../hooks/useAxiosPrivate"; // Updated path for axios hook
import { useAuth } from "../../hooks/useAuth"; // Assuming this path for useAuth hook

// Define AuthenticatedUser interface based on global.d.ts
// This is typically declared globally or in a shared types file
declare interface AuthenticatedUser {
  userId: string;
  email: string;
  role: string;
  // Add other properties if they are part of your AuthenticatedUser structure
}

// Define AuthContextType to match the expected return type of useAuth
// This assumes useAuth returns an object with an 'auth' property,
// and that 'auth' property contains the 'user' object.
interface AuthContextType {
  auth?: { // This 'auth' property holds the actual auth state
    user?: AuthenticatedUser | null; // User can be null or undefined if not authenticated
    accessToken?: string; // Assuming accessToken is also part of AuthType
    // Add other properties that your useAuth hook might return, e.g., setAuth, isLoading
  };
  // Add other properties that useAuth might return directly, e.g., setAuth, isLoading
}


// Type definitions (usually in a types/types.ts file)
type QuestionType = "multiple_choice" | "true_false" | "short_answer" | "ordering" | "poll";

interface Answer {
  text: string;
  isCorrect?: boolean;
}

interface Question {
  _id?: string; // Make _id optional for new questions (backend generates it)
  quizId: string;
  type: QuestionType;
  title: string; // Corresponds to 'title' in backend question schema/model
  timeLimit: number;
  answers?: Answer[]; // Corresponds to 'options' in backend question schema/model
  answerText?: string;
  correctOrder?: string[];
  createdAt: string;
  updatedAt: string;
}

interface Quiz {
  _id?: string; // Make _id optional for new quizzes (backend generates it)
  title: string;
  isPublic: boolean;
  description: string;
  questions: Question[]; // Frontend internal state, not directly sent to quiz creation API
  createdAt: string;
  updatedAt: string;
  user: string; // Corresponds to 'user' in backend quiz model, required
}

// useSaveQuiz Hook (from useSaveQuiz.ts)
function useSaveQuiz() {
  const queryClient = useQueryClient();
  const axiosInstance = useAxiosPrivate({ type: "default" });

  return useMutation({
    mutationFn: async (quiz: Omit<Quiz, "_id">) => {
      // 1. Create quiz: Only send fields defined in backend QuizRequest schema (title, description, isPublic, tags, user)
      const { questions, _id, ...quizData } = quiz; // Exclude _id when creating
      console.log("Payload to /quizzes:", quizData); // Log quiz payload
      const res = await axiosInstance.post("/quizzes", quizData);
      const createdQuiz = res.data as Quiz;
      console.log("Created Quiz from backend:", createdQuiz); // Log created quiz with its _id

      // 2. Create each question: Send questions to the /questions API
      await Promise.all(
        questions.map((q) => {
          console.log("Question object before destructuring _id:", q); // Log the question object before destructuring
          // Exclude _id for new questions, backend will generate it
          const { _id: questionId, ...questionData } = q; // q._id is undefined for new questions
          const questionPayload = {
            ...questionData, // This should correctly omit _id if it's undefined
            quizId: createdQuiz._id, // Use the _id generated by backend for the quiz
            options: q.answers, // Map frontend 'answers' to backend 'options'
          };
          console.log("Payload to /questions for question:", questionPayload); // Log question payload
          return axiosInstance.post("/questions", questionPayload);
        })
      );

      return createdQuiz;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/quizzes"] });
    },
  });
}

const { Title } = Typography;

// QuizForm Component (from quiz-form.tsx)
interface QuizFormProps {
  quiz: Quiz;
  setQuiz: (quiz: Quiz) => void;
}

function QuizForm({ quiz, setQuiz }: QuizFormProps) {
  const [form] = Form.useForm();

  useEffect(() => {
    form.setFieldsValue(quiz);
  }, [quiz, form]);

  const handleChange = (_: any, allValues: Quiz) => {
    setQuiz(allValues);
  };

  return (
    <Form
      form={form}
      layout="vertical"
      initialValues={quiz}
      onValuesChange={handleChange}
    >
      <Form.Item
        label="Quiz Title"
        name="title"
        rules={[{ required: true, message: "Title is required" }]}
      >
        <Input placeholder="Enter quiz title..." />
      </Form.Item>

      <Form.Item label="Description" name="description">
        <Input.TextArea placeholder="Add an optional description..." />
      </Form.Item>

      <Form.Item label="Public" name="isPublic" valuePropName="checked">
        <Switch />
      </Form.Item>
    </Form>
  );
}

// QuestionForm Component (from question-form.tsx)
interface QuestionFormProps {
  quizId: string;
  onAdd: (q: Question & Partial<{ answerText: string; correctOrder: string[] }>) => void;
  editingQuestion?: (Question & Partial<{ answerText: string; correctOrder: string[] }>) | null;
}

function QuestionForm({
  quizId,
  onAdd,
  editingQuestion,
}: QuestionFormProps) {
  const [form] = Form.useForm();
  const [questionType, setQuestionType] = useState<QuestionType>("multiple_choice");

  useEffect(() => {
    if (editingQuestion) {
      const answerTexts = editingQuestion.answers?.map((a) => a.text) || [];
      const correctIndexes =
        editingQuestion.answers
          ?.map((a, i) => (a.isCorrect ? i : -1))
          .filter((i) => i !== -1) || [];

      form.setFieldsValue({
        type: editingQuestion.type,
        title: editingQuestion.title,
        timeLimit: editingQuestion.timeLimit,
        answers: answerTexts.join("\n"),
        correctIndexes,
        answerText: editingQuestion.answerText,
        correctOrder: editingQuestion.correctOrder?.join("\n"),
      });

      setQuestionType(editingQuestion.type);
    } else {
      form.setFieldsValue({ type: "multiple_choice", timeLimit: 30 });
      setQuestionType("multiple_choice");
    }
  }, [editingQuestion, form]);

  const now = new Date().toISOString();

  const onFinish = (values: any) => {
    const base: Question = {
      quizId,
      type: questionType,
      title: values.title,
      timeLimit: values.timeLimit,
      createdAt: editingQuestion?.createdAt || now,
      updatedAt: now,
    };

    // Explicitly set _id to undefined for new questions or use existing _id for editing
    if (editingQuestion) {
        base._id = editingQuestion._id;
    } else {
        base._id = undefined; // Ensure _id is explicitly undefined for new questions
    }

    const question: Question & Partial<{ answerText: string; correctOrder: string[] }> = {
      ...base,
      answers: [], // Initialize answers as an empty array
    };

    if (questionType === "multiple_choice" || questionType === "true_false") {
      const answerLines = values.answers
        .split("\n")
        .filter((line: string) => line.trim() !== "");

      question.answers = answerLines.map((text: string, index: number) => ({
        text,
        isCorrect: values.correctIndexes?.includes(index) ?? false,
      }));
    } else if (questionType === "poll") { // Poll questions also have answers
      question.answers = values.answers
        .split("\n")
        .filter((line: string) => line.trim() !== "")
        .map((text: string) => ({ text }));
    }


    if (questionType === "short_answer") {
      question.answerText = values.answerText;
    }

    if (questionType === "ordering") {
      question.correctOrder = values.correctOrder
        .split("\n")
        .map((t: string) => t.trim())
        .filter(Boolean);
    }

    console.log("Question data being added (internal state):", question);
    onAdd(question);
    form.resetFields();
    setQuestionType("multiple_choice");
    form.setFieldsValue({ type: "multiple_choice", timeLimit: 30 });
  };

  return (
    <Form layout="vertical" onFinish={onFinish} form={form}>
      <Form.Item label="Question Type" name="type" rules={[{ required: true }]}>
        <Select
          onChange={(v) => {
            setQuestionType(v as QuestionType);
            form.setFieldsValue({ type: v });
          }}
        >
          <Select.Option value="multiple_choice">Multiple Choice</Select.Option>
          <Select.Option value="true_false">True/False</Select.Option>
          <Select.Option value="short_answer">Short Answer</Select.Option>
          <Select.Option value="ordering">Ordering</Select.Option>
          <Select.Option value="poll">Poll</Select.Option>
        </Select>
      </Form.Item>

      <Form.Item label="Question Title" name="title" rules={[{ required: true, message: "Question title is required" }]}>
        <Input placeholder="Enter question title..." />
      </Form.Item>

      {(questionType === "multiple_choice" ||
        questionType === "true_false" ||
        questionType === "poll") && (
        <>
          <Form.Item
            label="Answers (each line is one answer)"
            name="answers"
            rules={[{ required: true, message: "Please enter at least one answer" }]}
          >
            <Input.TextArea rows={4} placeholder="Answer 1\nAnswer 2\nAnswer 3" />
          </Form.Item>

          {questionType !== "poll" && (
            <Form.Item shouldUpdate={(prev, curr) => prev.answers !== curr.answers} noStyle>
              {({ getFieldValue }) => {
                const answersText = getFieldValue("answers") || "";
                const answers = answersText
                  .split("\n")
                  .filter((line: string) => line.trim() !== "");

                return answers.length > 0 ? (
                  <Form.Item
                    label="Correct Answer(s)"
                    name="correctIndexes"
                    rules={[{ required: true, message: "Please select correct answer(s)" }]}
                  >
                    <Select mode="multiple" placeholder="Select correct answer(s)">
                      {answers.map((text: string, index: number) => (
                        <Select.Option key={index} value={index}>
                          {text}
                        </Select.Option>
                      ))}
                    </Select>
                  </Form.Item>
                ) : null;
              }}
            </Form.Item>
          )}
        </>
      )}

      {questionType === "short_answer" && (
        <Form.Item
          label="Correct Answer Text"
          name="answerText"
          rules={[{ required: true, message: "Correct answer text is required" }]}
        >
          <Input placeholder="Exact correct answer text" />
        </Form.Item>
      )}

      {questionType === "ordering" && (
        <Form.Item
          label="Correct Order (each line is one item)"
          name="correctOrder"
          rules={[{ required: true, message: "Correct order is required" }]}
        >
          <Input.TextArea rows={4} placeholder="Step 1\nStep 2\nStep 3" />
        </Form.Item>
      )}

      <Form.Item
        label="Time Limit (seconds)"
        name="timeLimit"
        rules={[{ required: true, message: "Time limit is required" }]}
      >
        <Input type="number" min={5} placeholder="Enter time limit (seconds)" />
      </Form.Item>

      <Button htmlType="submit" type="primary" className="rounded-md shadow-sm hover:shadow-md transition-all">
        {editingQuestion ? "Update Question" : "Add Question"}
      </Button>
    </Form>
  );
}

// QuestionList Component (from question-list.tsx)
interface QuestionListProps {
  questions: Question[];
  onEdit: (q: Question) => void;
  onDelete: (id: string) => void;
}

function QuestionList({ questions, onEdit, onDelete }: QuestionListProps) {
  const getColorByType = (type: string) => {
    switch (type) {
      case "multiple_choice":
        return "blue";
      case "true_false":
        return "green";
      case "poll":
        return "gold";
      case "ordering":
        return "purple";
      case "short_answer":
        return "red";
      default:
        return "default";
    }
  };

  return (
    <List
      bordered
      dataSource={questions}
      locale={{ emptyText: "No questions added yet." }}
      renderItem={(q, index) => (
        <List.Item
          actions={[
            <Tooltip title="Edit">
              <Button
                icon={<EditOutlined />}
                size="small"
                onClick={() => onEdit(q)}
                className="rounded-md"
              />
            </Tooltip>,
            <Tooltip title="Delete">
              <Button
                icon={<DeleteOutlined />}
                size="small"
                danger
                onClick={() => onDelete(q._id)}
                className="rounded-md"
              />
            </Tooltip>,
          ]}
        >
          <div className="w-full">
            <div className="flex items-center justify-between">
              <div className="font-medium text-gray-800">
                {index + 1}. {q.title}
                <Tag color={getColorByType(q.type)} className="ml-2 rounded-full px-3 py-1 text-xs">
                  {q.type.replace("_", " ").toUpperCase()}
                </Tag>
              </div>
              <div className="text-xs text-gray-500 flex items-center gap-1">
                <ClockCircleOutlined />
                {q.timeLimit}s
              </div>
            </div>

            {q.answers && q.answers.length > 0 && (
              <ul className="list-disc ml-6 mt-2 text-sm text-gray-700">
                {q.answers.map((a, i) => (
                  <li
                    key={i}
                    className={a.isCorrect ? "font-bold text-green-600" : ""}
                  >
                    {a.text}
                  </li>
                ))}
              </ul>
            )}

            {q.correctOrder && (
              <ol className="list-decimal ml-6 mt-2 text-sm text-gray-700">
                {q.correctOrder.map((step, i) => (
                  <li key={i}>{step}</li>
                ))}
              </ol>
            )}

            {q.answerText && (
              <p className="ml-6 mt-2 text-sm text-gray-700">
                Correct Answer:{" "}
                <span className="font-semibold text-green-600">{q.answerText}</span>
              </p>
            )}
          </div>
        </List.Item>
      )}
    />
  );
}


// Main QuizBuilder Component
export default function QuizBuilder() {
  const navigate = useNavigate();
  // Destructure 'auth' property, assuming useAuth returns an object with 'auth'
  const { auth } = useAuth() as AuthContextType; // Explicitly cast to AuthContextType

  const [quizInfo, setQuizInfo] = useState<Quiz>({
    // Do NOT generate _id here. Backend will generate it.
    title: "",
    isPublic: false,
    description: "",
    questions: [],
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    // Access userId through auth.user.userId
    user: auth?.user?.userId || "",
  });

  const [editingQuestion, setEditingQuestion] = useState<Question | null>(null);

  // Use the useSaveQuiz hook for saving logic
  const { mutate: saveQuiz, isPending } = useSaveQuiz();

  const addOrUpdateQuestion = (question: Question) => {
    setQuizInfo((prev) => {
      // Ensure prev.questions is an array before calling find or map
      const currentQuestions = prev.questions || [];
      const exists = currentQuestions.find((q) => q._id === question._id);
      const updated = exists
        ? currentQuestions.map((q) => (q._id === question._id ? question : q))
        : [...currentQuestions, question];
      return { ...prev, questions: updated };
    });
    setEditingQuestion(null); // Clear editing state after add/update
  };

  const deleteQuestion = (id: string) => {
    setQuizInfo((prev) => ({
      ...prev,
      questions: (prev.questions || []).filter((q) => q._id !== id), // Ensure prev.questions is an array
    }));
  };

  const handleSaveQuiz = () => {
    if (!quizInfo.title.trim()) {
      message.error("Quiz title cannot be empty!");
      return;
    }
    if (!quizInfo.questions || quizInfo.questions.length === 0) {
      message.warning("Please add at least one question to the quiz.");
      return;
    }
    // Ensure user ID is present before saving
    if (!quizInfo.user) {
      message.error("User ID is missing. Please log in.");
      return;
    }

    console.log("Quiz data being saved:", quizInfo);

    // Call the mutate function from useSaveQuiz hook
    saveQuiz(quizInfo, {
      onSuccess: () => {
        message.success("Quiz saved successfully!");
        navigate("/admin/quiz-management"); // Redirect after successful save
      },
      onError: (err: any) => {
        console.error("Failed to save quiz:", err.response || err);
        message.error(err.response?.data?.message || "Failed to save quiz.");
      },
    });
  };

  return (
    <section className="max-w-5xl mx-auto p-6 space-y-8 bg-gray-50 min-h-screen rounded-xl shadow-lg font-sans">
      {/* Header Section */}
      <Flex justify="space-between" align="center" wrap="wrap" gap="middle">
        <Title level={3} className="m-0 text-gray-800">
          🎨 Create New Quiz
        </Title>
        <div className="flex flex-wrap gap-2">
          <Button
            onClick={() => navigate("/admin/question-management")}
            className="rounded-md shadow-sm hover:shadow-md transition-all"
          >
            Question Management
          </Button>
          <Button
            onClick={() => navigate("/admin/quiz-management")}
            className="rounded-md shadow-sm hover:shadow-md transition-all"
          >
            Back to Quiz List
          </Button>
        </div>
      </Flex>

      {/* Quiz Form Section */}
      <div className="bg-white p-6 rounded-xl shadow-md">
        <Title level={4} className="mb-4 text-gray-700">Quiz Information</Title>
        <QuizForm quiz={quizInfo} setQuiz={setQuizInfo} />
      </div>

      <Divider className="my-6" />

      {/* Question Form Section */}
      <div className="bg-white p-6 rounded-xl shadow-md">
        <Title level={4} className="mb-4 text-gray-700">Add/Edit Question</Title>
        <QuestionForm
          quizId={quizInfo._id || ""} // Pass quizId (can be empty for new quiz until saved)
          onAdd={addOrUpdateQuestion}
          editingQuestion={editingQuestion}
          key={editingQuestion?._id || "new"} // Key helps re-mount form when editingQuestion changes
        />
      </div>

      <Divider className="my-6" />

      {/* Question List Section */}
      <div className="bg-white p-6 rounded-xl shadow-md">
        <Title level={4} className="mb-4 text-gray-700">Quiz Questions</Title>
        <QuestionList
          questions={quizInfo.questions || []}
          onEdit={(q) => setEditingQuestion(q)}
          onDelete={deleteQuestion}
        />
      </div>

      {/* Save Quiz Button */}
      <Button
        type="primary"
        block
        size="large"
        onClick={handleSaveQuiz}
        loading={isPending}
        disabled={!quizInfo.questions || quizInfo.questions.length === 0 || !quizInfo.title.trim() || !quizInfo.user}
        className="rounded-md shadow-lg hover:shadow-xl transition-all mt-8"
      >
        {isPending ? "Saving Quiz..." : "Save Quiz"}
      </Button>
    </section>
  );
}
